#version 460 core
layout(local_size_x=256, local_size_y=1, local_size_z=1) in;

struct TriGPU
{
    vec4 v0; vec4 v1; vec4 v2;
    vec4 n0; vec4 n1; vec4 n2;
    vec4 uv0; vec4 uv1; vec4 uv2;
    ivec4 mat;
};

struct NodeGPU
{
    vec4 bmin;
    vec4 bmax;
    ivec4 meta;
};

layout(std430, binding=10) readonly buffer TrisBuf { TriGPU tris[]; };
layout(std430, binding=11) buffer NodesBuf { NodeGPU nodes[]; };

uniform int u_NodeCount;
uniform int u_Pass;

vec3 vmin3(vec3 a, vec3 b) { return vec3(min(a.x,b.x), min(a.y,b.y), min(a.z,b.z)); }
vec3 vmax3(vec3 a, vec3 b) { return vec3(max(a.x,b.x), max(a.y,b.y), max(a.z,b.z)); }

void main()
{
    uint id = gl_GlobalInvocationID.x;
    if (int(id) >= u_NodeCount) return;

    NodeGPU n = nodes[id];

    int left = n.meta.x;
    int right = n.meta.y;
    int first = n.meta.z;
    int count = n.meta.w;

    if (first >= 0 && count > 0)
    {
        vec3 mn = vec3( 1e30);
        vec3 mx = vec3(-1e30);

        for (int i = 0; i < count; ++i)
        {
            int ti = first + i;
            TriGPU t = tris[ti];

            vec3 p0 = t.v0.xyz;
            vec3 p1 = t.v1.xyz;
            vec3 p2 = t.v2.xyz;

            mn = vmin3(mn, vmin3(p0, vmin3(p1, p2)));
            mx = vmax3(mx, vmax3(p0, vmax3(p1, p2)));
        }

        n.bmin = vec4(mn, 0.0);
        n.bmax = vec4(mx, 0.0);
        nodes[id] = n;
        return;
    }

    if (left >= 0 && right >= 0)
    {
        NodeGPU a = nodes[left];
        NodeGPU b = nodes[right];

        vec3 mn = vmin3(a.bmin.xyz, b.bmin.xyz);
        vec3 mx = vmax3(a.bmax.xyz, b.bmax.xyz);

        n.bmin = vec4(mn, 0.0);
        n.bmax = vec4(mx, 0.0);
        nodes[id] = n;
        return;
    }
}
